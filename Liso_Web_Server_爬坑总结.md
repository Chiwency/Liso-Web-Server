## 这是一个爬坑总结

前后写了将近两周吧，期间爬了很多坑，从lex劝退到被学长劝回，才开始静下心硬刚，虽然简化了一些东西（比如没做CGI,~~简化了错误处理+daemon shutdown，，~~），但是做完之后能明显感觉对网络编程这一块有了更深的理解，做这个Lab的主要目的已经达到了。

下面主要写一下自己做这个Lab的过程中爬过的一些坑并且总结出的一些经验教训。

## CP1

  真的是万事开头难，CP1我感觉应该是整个Lab中最难的一部分，有几个主要难点。

+ 因为要求用yacc解析，但是自己又不会，就用了GitHub上其他人写好的代码。但是那位推代码的人自己写的也有错，还不容易查到。坑我最狠的一个问题是下面这条代码：

  ```c
  		parsing_request->headers = (Request_header *)realloc(parsing_request->headers, sizeof(Request_header *) * parsing_request->header_capacity);
  ```

  其中 `sizeof(Request_header *)` 这里计算的是指针类型的大小，而不是``Request_header `` 本身的大小，这样的`realloc()`还不会报错， 但是在实际测试的时候，如果`request headers` 超出大小触发`realloc()`的时候，达不到预期的效果，会丢失大部分`header`数据。 我一开始根本没去想我拉下来的代码有问题，，，，后来在各个环节反复打印出缓冲区内容，反复测试才定位到错误。

  

### 磨刀不误砍柴工：要善用debug工具如GDB

  Lab的文档里面强调了这一点，要善用调试工具。但是我开始根本没当回事，，， 因为之前碰到的错误都能用`printf()` 打印中间参数，然后自己推断出来，虽然很麻烦，但是我图它简单，，，前面定位那个错误的时候也是反复`printf`，，，， 一旦错误比较隐蔽就很耗费时间。

  后来开始转用GDB是因为碰到了一个不能靠`printf()` 定位的错误：指针引用错误

+ 在处理客户端请求的时候，要反复`malloc() free()`  其中有一个判断条件是`if (client->request)`  

即如果`request` 不为空，就处理`request` ， 每次处理完要`free(request)` 。本来逻辑就是对的，但是测试的时候，前几次测试都能成功，但是再测就会引发指针引用错误，而且具体是在第几次测试的时候才crash完全是随机的。这种情况用`printf` 就不可行了，最后迫不得已用gdb，因为gdb能定位到引发错误的位置，打印出调用栈，而且可以设置断点，打印中间变量(但是有大小限制，这点很鸡肋)。

最后发现错误原因是在每次`free(request)` 之后，`request`这个指针并不会自动置为`NULL`，而且，即使它是局部变量，下次再调用该函数的时候，`request`声明的位置很有可能就是原来的位置(通过打印地址发现地址一样)，而值又不是`NULL` 所以直接引用的话就会触发异常了。



***所以在每次free()之后要把指针置为NULL***

也是这点让我想继续看操作系统的Memoey部分



***而对于栈内存的变量，比如声明`char buf[8192]` 每次使用前务必要调用`memset()` 初始化***

因为C语言在声明变量的时候又不会初始化变量，很有可能`buf[]`里面还有一个完整的字符串，这导致我在处理请求的时候用`strcat()` 产生了混乱，被之前遗留的脏数据影响了。 这又是我debug好久之后才发现的问题，，，，，

归根结底也是写之前对C语言了解不多，不过以后要是能了解底层原因就更好了



+ cp1中还有一个主要功能实现就是`select()`多路复用，这个要自己查文档，认真看文档才能避开很多坑，而且select()的结构怎么用要好好设计



### 多看官方文档

​     这也不是要求所有问题都先去找官方文档解决，主要还是看具体需求。比如我在写的过程中经常要看某一个C库函数的含义和用法，一般就先去看官方文档，完整的看一遍，比如select()的文档，可以对它有一个较为全面的了解。但是要用的话，我一般就是直接搜`select() example in c` ，之类之类的。因为其他网站的例子更全，更能加深理解，死磕文档我觉得没必要。还有在忘了返回值，或者某些参数意义的时候，我直接按需求搜，而不是去官方文档找，因为直接搜感觉更快一点。 但是千万要注意用英文搜，但凡带了个中文，一般问题类的，基本都是出一堆的CSDN，夹杂着一堆的广告，有种垃圾场里挑食的感觉，就挺难受的。



### 有问题多看stackoverflow

   不得不说stackoverflow真的是众多网站中质量最高的之一，只要你搜索的关键词得当的话，真的能解决大部分问题。Google的话带上`site: "stackoverflow"`关键词搜索就可以了。

  需要注意的是，stackoverflow上的回答也不一定是对的，要注意看一下回答下面的评论，有没有人反驳，如果有人反驳，就得仔细看了。

  我之前查一个"服务端如果判断客户端关闭了TCP连接"。上面有人说`read()`返回值为0就算是断了连接。但这是普遍的误区，`read()`返回0的情况有很多，连接断开只是其中一种情况。 所以我们需要对上面的内容进行甄别。



### POST请求是分两次发送

   这和我之前的认知不一样，看了RFC文档才发现。一般来说客户端先会发送请求头部，等待服务器确认可以接受body部分，返回`100 continue`，之后再发送`body`部分。 还有请求方法的幂等性，安全性，需要服务器自己注意下，我写的可没考虑那么多，，，，



## cp2

  CP2的难点是实现pipeline。 这里Lab的handout没有给示例代码，需要自己爬坑。所以我自己去搜了相关文章。RFC里的描述很简单，要再综合看一下其他网站的文章. 后来还看到了HTTP2.0的Multiplexing。

   在CP1里面每次处理完请求后，服务器都主动关闭连接，所以这次加上pipeline之后要对代码架构有很大的改动，我又加了连接池，`client` 结构体这些东西，嗯，，，连接池是按我臆想设计的，，，听起来很高大上吧，，



### TCP是全双工连接

  之前学的时候对全双工的概念了解不深。在实现Pipeline的时候，我以为socket file是和其他文件一样的是一个正常的文件，如果我在处理第一个请求，往socket里写入的时候，又有数据到了，会不会覆盖掉socket缓冲区的数据。后来去网上查了一圈才搞明白，大概是Linux为了复用处理文件的接口（我猜测，，，），所以才有一切皆文件的思想，而针对一些外设，硬件设备，把它们看成是一个文件。但是这种类型的文件和其他文件比有一些不同，比如说没有文件大小的属性，总之这时候可以把socket当成一个硬件来看(网卡)。在硬件层面上有上行和下行两条线路支持，所以读写互不干扰，这就是说TCP靠两条物理线路实现全双工。（一条线的话就能实现半双工），就像测网速的时候一般有上行和下行速度。



这部分好像没爬什么坑，主要是重新设计了一下整体处理架构，很麻烦，但是至少没什么奇妙的bug搞心态。



## CP3

   感觉这部分挺简单的，都有Example, 就像是给了一堆函数然后自己做填空题，重要的就是要理解每个函数调用的意义，这部分要多看文档。 CGI在CSAPP里面看过了，就没写了。

+ HTTPS之前只知道原理，不知道具体实现，做之前还挺感兴趣的，以为要自己手动实现四次握手，后来看Example才发现是调OpenSSL的库，淦，好无聊。 handout给的生成证书的代码也有问题，在我机器上跑不了，只能自己一条条执行，还要自己去下SSL标准库，不过倒是没遇到什么麻烦的问题
+ Daemonlizaton 也是看Example Code 就行，然后有一个信号处理，这个在CSAPP第八章的Lab也有讲，没什么难点，套代码，，，，





## 一些感悟

   做完Lab可以说对C语言的了解又更近一步了，更能体会它为什么是一门经久不衰的语言，而不是像之前只是停留在语法层面。这种收获不是光看书能得来的，还是要自己实践呀。

  万事开头难，做完CP1其实就做完大半的Lab了，所以刚开始一定要坚持住呀，不要遇到一些问题就被劝退了。

  锻炼软技能，主要是提升了自己的信息检索能力，信息甄别的能力，还有知识的接受能力，能够通过网络快速学习，上手。虽然这些东西很玄，但确实是必不可少的。